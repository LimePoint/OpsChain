#!/bin/bash
set -eo pipefail

# Most of the util functions in this file are called from within a subshell Eg.
# myvar=$(<util function>).
#
# In the example above, any echo statements issued inside the util function end
# up being assigned to myvar. This is awkward if the functions wish to print
# their error messages or in the case of yn() where it needs to print the
# question the user is to respond to! To enable the util functions to send
# messages to STDOUT or STDERR the following redirections are added. The
# print_msg function above can then use >&7 to print to stdout and >&8 to print
# to stderr.
exec 7>&1 8>&2

source "$(CDPATH='' cd -- "$(dirname -- "${BASH_SOURCE[0]}")"; pwd)/bin/_realpath.sh"

trap on_exit EXIT

on_exit() {
  if [[ $? != 0 ]]; then
    exec >&2
    echo
    echo 'The configure script failed.'
    echo 'Your configuration may not be updated.'
  fi
}

quote() {
  printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"
}

print_msg() {
  local echo_target
  echo_target=7
  if [ "$(eval echo \$$#)" == "ERR" ]; then
    echo_target=8
    set -- "${@:1:$(($# - 1))}"
  fi
  echo "$@" >&${echo_target}
}

yn() {
  local lp_prompt
  local l_answer l_ret_val l_regex

  lp_prompt="$1"
  l_regex='yes|no'

  until [[ $l_ret_val =~ $l_regex ]]; do
    print_msg -n "$lp_prompt"
    read -r -n1 l_answer

    case "$l_answer" in
    y | Y) l_ret_val=yes ;;
    n | N) l_ret_val=no ;;
    *)
      print_msg "" ERR
      print_msg "Please try again - only y or n is permitted." ERR
      ;;
    esac
  done

  print_msg
  echo "$l_ret_val"
}

load_saved_settings() {
  local lp_env_file
  lp_env_file="$1"

  set -o allexport
  [[ -f "$lp_env_file" ]] && source "$lp_env_file"
  set +o allexport
}

validate_settings() {
  confirm_socket_path
  approve_socket
  confirm_data_path
  confirm_port
  confirm_log_host
  confirm_workers
}

read_configuration_keys() {
  for file in "$@"; do
    if [ -e "$file" ]; then
      while IFS='=' read -r var _; do
        if ! [[ $var =~ $blank_line || $var =~ $comment_line ]]; then
          echo "$var"
        fi
      done < "$file"
    fi
  done | awk '!a[$0]++'
}

save_settings() {
  local lp_env_file example_env_file env_file_contents
  lp_env_file="$1"
  example_env_file="$2"

  blank_line="^[[:blank:]]*$"
  comment_line="^#"

  env_file_contents="# Note: See docs/operations/configuring_opschain.md for the complete list of configurable options\n\n"

  # use example env file as a template, accumulate key=value pairs
  for var in $(read_configuration_keys "${example_env_file}" "${lp_env_file}"); do
    env_file_contents="${env_file_contents}${var}=$(quote "${!var}")\n"
  done

  echo -e "${env_file_contents}" > "${lp_env_file}"
  chmod 600 "${lp_env_file}"

  echo "Configuration saved to ${lp_env_file}"
}

confirm_socket_path() {
  local l_socket_path l_environment_socket_path

  if [[ -z "$OPSCHAIN_DOCKER_SOCKET_PATH" ]]; then
    l_environment_socket_path="${DOCKER_HOST#unix://}"
    OPSCHAIN_DOCKER_SOCKET_PATH="${l_environment_socket_path:-/var/run/docker.sock}"
  fi

  print_msg -n "Where is your Docker socket file located? [${OPSCHAIN_DOCKER_SOCKET_PATH}]: "
  read -r l_socket_path
  l_socket_path="${l_socket_path:-${OPSCHAIN_DOCKER_SOCKET_PATH}}"

  export OPSCHAIN_DOCKER_SOCKET_PATH="${l_socket_path}"

  if ! [ -e "${OPSCHAIN_DOCKER_SOCKET_PATH}" ]; then
    print_msg "${OPSCHAIN_DOCKER_SOCKET_PATH} does not appear to exist." ERR
    print_msg "Please ensure that your Docker daemon is running." ERR
    exit 2
  fi
}

confirm_data_path() {
  local l_data_path

  print_msg -n "Where would you like OpsChain to store its data files? [${OPSCHAIN_DATA_DIR}]: "
  read -r l_data_path
  l_data_path="$(realpath "${l_data_path:-${OPSCHAIN_DATA_DIR}}")"

  export OPSCHAIN_DATA_DIR="${l_data_path}"

  ensure_path_exists "$OPSCHAIN_DATA_DIR"
  create_directory "${OPSCHAIN_DATA_DIR}/opschain_ldap/ldap"
  create_directory "${OPSCHAIN_DATA_DIR}/opschain_ldap/slapd.d"
  create_directory "${OPSCHAIN_DATA_DIR}/opschain_auth"
  create_directory "${OPSCHAIN_DATA_DIR}/opschain_log_aggregator/plugin"
  create_directory "${OPSCHAIN_DATA_DIR}/opschain_log_aggregator/bundler"
  (
    dest="${OPSCHAIN_DATA_DIR}/opschain_auth"
    cd opschain_auth.tmpl
    for file in *; do
      if ! [[ -e "${dest}/${file}" ]]; then
        cp "${file}" "${dest}"
      fi
    done
  )
}

ensure_path_exists() {
  local check_path
  check_path="${1}"

  local l_proceed

  if [ ! -d "${check_path}" ]; then
    l_proceed="$(yn "The path ${check_path} doesn't exist - would you like to create it? ")"
    if [ "${l_proceed}" == "yes" ]; then
      echo "Creating ${check_path}..."
      create_directory "${check_path}"
      echo "${check_path} created successfully."
    else
      print_msg "Path must exist in order for OpsChain to work." ERR
      exit 2
    fi
  fi
  echo
}

create_directory() {
  local path
  path="${1}"

  if [ ! -d "${path}" ]; then
    if ! mkdir -p "${path}"; then
      echo "Failed to create ${path} - aborting configuration."
      exit 2
    fi
  fi
}

function to_int() {
  local -i num="10#${1}"
  echo "${num}"
}

get_integer() {
  local lp_prompt lp_default
  local -i lp_min lp_max
  local l_value l_valid_value

  lp_prompt="$1"
  lp_min="$2"
  lp_max="$3"
  lp_default="$4"

  l_valid_value='N'

  while [ "${l_valid_value}" == 'N' ]; do
    print_msg
    print_msg -n "${lp_prompt} (${lp_min}-${lp_max})? [${lp_default}]: "
    read -r l_value
    l_value="${l_value:-${lp_default}}"

    int_check=$(to_int "${l_value}" 2>/dev/null)

    if ((int_check < lp_min || int_check > lp_max)); then
      print_msg "${l_value} is not a valid value - it must be between ${lp_min} and ${lp_max}." ERR
    else
      l_valid_value='Y'
    fi
  done

  echo "$l_value"

}

confirm_port() {
  api_port=${OPSCHAIN_API_PORT_MAPPING%:*}
  api_port=$(get_integer "Which available port would you like the OpsChain server to listen on" 1 65535 "${api_port:-3000}")
  export OPSCHAIN_API_PORT_MAPPING="${api_port}:3000"
}

confirm_workers() {
  export OPSCHAIN_API_WORKER_SCALE=$(get_integer "How many OpsChain worker nodes would you like to run (will limit how many actions can run in parallel)" 1 50 "${OPSCHAIN_API_WORKER_SCALE:-2}")
}

approve_socket() {
  print_msg
  print_msg "OpsChain requires access to your host Docker daemon to function."
  print_msg "This is achieved by volume mapping ${OPSCHAIN_DOCKER_SOCKET_PATH} from the host into the running container."
  print_msg
  if [ "$(yn "Do you approve of this mapping being added? ")" != "yes" ]; then
    print_msg "You must approve this in order to use OpsChain." ERR
    exit 2
  fi
  echo
}

confirm_log_host() {
  print_msg
  if [ "$(yn 'Are you running OpsChain on Windows (WSL) or macOS (yn) ? ')" = "yes" ]; then
    export OPSCHAIN_LOG_AGGREGATOR_HOST=host.docker.internal
  else
    export OPSCHAIN_LOG_AGGREGATOR_HOST=127.0.0.1
  fi
}

load_mintpress_licence() {
  licence_file="$(shopt -s nullglob; set -- mintpress.licen[cs]e; echo -n "${1:-mintpress.licence}")"
  if [ -e "${licence_file}" ]; then
    MINTPRESS_SDK_LICENCE_BASE64="$(base64 < "${licence_file}")"
    # remove whitespace to avoid breaking encoded licence
    MINTPRESS_SDK_LICENCE_BASE64="${MINTPRESS_SDK_LICENCE_BASE64//[$'\t\r\n ']}"
    print_msg "Loaded MintPress licence from ${licence_file}"
    export MINTPRESS_SDK_LICENCE_BASE64
  else
    print_msg "Unable to load the MintPress licence from ${licence_file}" ERR
    exit 2
  fi
}

generate_secrets() {
  PGPASSWORD=${PGPASSWORD:-$(openssl rand -hex 8)}
  OPSCHAIN_ENCRYPTION_KEY=${OPSCHAIN_ENCRYPTION_KEY:-$(openssl rand -hex 32)}
  OPSCHAIN_LDAP_PASSWORD=${OPSCHAIN_LDAP_PASSWORD:-$(openssl rand -hex 8)}
  OPSCHAIN_CREATE_LOGS_API_PASSWORD=${OPSCHAIN_CREATE_LOGS_API_PASSWORD:-$(openssl rand -hex 8)}
}

set_permissions_ids() {
  OPSCHAIN_UID=${OPSCHAIN_UID:-$(id -u)}
  OPSCHAIN_GID=${OPSCHAIN_GID:-$(id -g)}
  echo "OpsChain will run as $OPSCHAIN_UID:$OPSCHAIN_GID (your current user:group)"
}

example_env_file=".env.example"

load_saved_settings "${example_env_file}"
load_saved_settings ".env"
load_mintpress_licence
generate_secrets
set_permissions_ids

validate_settings
save_settings ".env" "${example_env_file}"
