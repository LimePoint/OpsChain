#!/bin/bash
set -eo pipefail

# Most of the util functions in this file are called from within a subshell Eg.
# myvar=$(<util function>).
#
# In the example above, any echo statements issued inside the util function end
# up being assigned to myvar. This is awkward if the functions wish to print
# their error messages or in the case of yn() where it needs to print the
# question the user is to respond to! To enable the util functions to send
# messages to STDOUT or STDERR the following redirections are added. The
# print_msg function above can then use >&7 to print to stdout and >&8 to print
# to stderr.
exec 7>&1 8>&2

source "$(CDPATH='' cd -- "$(dirname -- "${BASH_SOURCE[0]}")"; pwd)/_realpath.sh"

CDPATH='' cd -- "$(dirname -- "${BASH_SOURCE[0]}")"
cd ..

trap on_exit EXIT

on_exit() {
  if [[ $? != 0 ]]; then
    exec >&2
    echo
    echo 'The configure script failed.'
    echo 'Your configuration may not be updated.'
  fi
}

quote() {
  printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"
}

print_msg() {
  local echo_target
  echo_target=7
  if [ "$(eval echo \$$#)" == "ERR" ]; then
    echo_target=8
    set -- "${@:1:$(($# - 1))}"
  fi
  echo "$@" >&${echo_target}
}

yn() {
  local lp_prompt
  local l_answer l_ret_val l_regex

  lp_prompt="$1"
  l_regex='yes|no'

  until [[ $l_ret_val =~ $l_regex ]]; do
    print_msg -n "$lp_prompt"
    read -r -n1 l_answer

    case "$l_answer" in
    y | Y) l_ret_val=yes ;;
    n | N) l_ret_val=no ;;
    *)
      print_msg "" ERR
      print_msg "Please try again - only y or n is permitted." ERR
      ;;
    esac
  done

  print_msg
  echo "$l_ret_val"
}

load_saved_settings() {
  local lp_env_file
  lp_env_file="$1"

  if [[ -f "$lp_env_file" ]]; then
    source "$lp_env_file"
  fi
}

confirm_eula() {
  if [[ "${OPSCHAIN_LICENCE_ACCEPTED}" = yes ]]; then
    return
  fi
  local l_accept
  print_msg
  print_msg "Usage of this software is subject to LimePoint’s standard [End User Licence Agreement](https://opschain.io/files/LimePoint-OpsChain-EULA.pdf) (or, if applicable, other terms agreed with LimePoint)."
  print_msg
  l_accept="$(yn "Do you accept LimePoint’s standard End User Licence Agreement (or, if applicable, other terms agreed with LimePoint)? ")"

  if [[ ${l_accept} != yes ]]; then
    print_msg "This software can't be used if the LimePoint EULA (or other agreed terms) is not accepted." ERR
    exit 2
  fi
  export OPSCHAIN_LICENCE_ACCEPTED=yes
}

validate_settings() {
  confirm_docker_credentials
  confirm_github_credentials
  confirm_ports
  confirm_workers
  confirm_node_platform
  confirm_eula
}

read_configuration_keys() {
  blank_line="^[[:blank:]]*$"
  comment_line="^#"

  for file in "$@"; do
    if [ -e "$file" ]; then
      while IFS='=' read -r var _; do
        if ! [[ $var =~ $blank_line || $var =~ $comment_line ]]; then
          echo "$var"
        fi
      done < "$file"
    fi
  done | awk '!a[$0]++'
}

save_settings() {
  local lp_env_file example_env_file env_file_contents
  lp_env_file="$1"
  example_env_file="$2"

  env_file_contents="# Note: See docs/operations/configuring_opschain.md for the complete list of configurable options\n\n"

  # use example env file as a template, accumulate key=value pairs
  for var in $(read_configuration_keys "${example_env_file}" "${lp_env_file}"); do
    env_file_contents="${env_file_contents}${var}=$(quote "${!var}")\n"
  done

  echo -e "${env_file_contents}" > "${lp_env_file}"
  chmod 600 "${lp_env_file}"

  echo "Configuration saved to ${lp_env_file}"
}

function to_int() {
  local -i num="10#${1}"
  echo "${num}"
}

get_integer() {
  local lp_prompt lp_default
  local -i lp_min lp_max
  local l_value l_valid_value

  lp_prompt="$1"
  lp_min="$2"
  lp_max="$3"
  lp_default="$4"

  l_valid_value='N'

  while [ "${l_valid_value}" == 'N' ]; do
    print_msg -n "${lp_prompt} (${lp_min}-${lp_max})? [${lp_default}]: "
    read -r l_value
    l_value="${l_value:-${lp_default}}"

    int_check=$(to_int "${l_value}" 2>/dev/null)

    if ((int_check < lp_min || int_check > lp_max)); then
      print_msg "${l_value} is not a valid value - it must be between ${lp_min} and ${lp_max}." ERR
    else
      l_valid_value='Y'
    fi
  done

  echo "$l_value"

}

confirm_ports() {
  if ${OPSCHAIN_INSECURE_HTTP_PORT_ENABLED}; then
    OPSCHAIN_API_EXTERNAL_PORT=$(get_integer "Which available port would you like the OpsChain server to listen on for HTTP requests" 1 65535 "${OPSCHAIN_API_EXTERNAL_PORT:-3000}")
  fi
  OPSCHAIN_TLS_EXTERNAL_PORT=$(get_integer "Which available port would you like the OpsChain server to listen on for HTTPS requests" 1 65535 "${OPSCHAIN_TLS_EXTERNAL_PORT:-3443}")
  export OPSCHAIN_API_EXTERNAL_PORT OPSCHAIN_TLS_EXTERNAL_PORT
}

confirm_github_credentials() {
  if [[ -n "${OPSCHAIN_GITHUB_TOKEN}" ]]; then
    return
  fi

  while [ "${OPSCHAIN_GITHUB_USER}" == '' ]; do
    print_msg -n "Please enter your GitHub username with OpsChain access: "
    read -r OPSCHAIN_GITHUB_USER
  done

  while [ "${OPSCHAIN_GITHUB_TOKEN}" == '' ]; do
    print_msg -n "Please enter your GitHub personal access token: "
    read -r OPSCHAIN_GITHUB_TOKEN
  done

  export OPSCHAIN_GITHUB_USER OPSCHAIN_GITHUB_TOKEN
}

confirm_docker_credentials() {
  if [[ -n "${OPSCHAIN_DOCKER_PASSWORD}" ]]; then
    return
  fi

  local l_docker_password l_enterprise
  l_enterprise="$(yn "Are you using OpsChain with the enterprise MintPress controllers? (If unsure, answer \`n\`) ")"
  if [[ "$l_enterprise" == yes ]]; then
    OPSCHAIN_DOCKER_USER=opschainenterprise
    OPSCHAIN_RUNNER_NAME=runner-enterprise
  else
    OPSCHAIN_DOCKER_USER=opschaintrial
    OPSCHAIN_RUNNER_NAME=runner
  fi
  print_msg -n "Please enter your OpsChain Docker Hub access token (contact opschain-support@limepoint.com to obtain if you don't have one): "
  read -r l_docker_password

  export OPSCHAIN_DOCKER_USER OPSCHAIN_DOCKER_PASSWORD="${l_docker_password}"
}

confirm_workers() {
  OPSCHAIN_API_WORKER_SCALE=$(get_integer "How many OpsChain worker nodes would you like to run (this will limit how many actions can run in parallel)" 1 50 "${OPSCHAIN_API_WORKER_SCALE:-2}")
  export OPSCHAIN_API_WORKER_SCALE
}

confirm_node_platform() {
  if [[ -n "${OPSCHAIN_IMAGE_REGISTRY_HOST}" ]]; then
    return
  fi

  if [ "$(yn 'Are you running OpsChain on Windows (WSL) (yn) ? ')" = "yes" ] || [ "$(yn 'Are you running OpsChain on macOS (yn) ? ')" = "yes" ]; then
    OPSCHAIN_IMAGE_BUILD_ROOTLESS=false
    OPSCHAIN_IMAGE_REGISTRY_HOST=host.docker.internal
  else
    OPSCHAIN_IMAGE_BUILD_ROOTLESS=true
    OPSCHAIN_IMAGE_REGISTRY_HOST=opschain-image-registry.local.gd
  fi

  export OPSCHAIN_IMAGE_REGISTRY_HOST OPSCHAIN_IMAGE_BUILD_ROOTLESS
}

check_opschain_licence() {
  licence_file="opschain.lic"
  if ! [ -e "${licence_file}" ]; then
    print_msg "Unable to load the OpsChain licence from ${licence_file}" ERR
    exit 2
  fi
}

generate_secrets() {
  PGPASSWORD=${PGPASSWORD:-$(openssl rand -hex 8)}
  OPSCHAIN_KEY_DERIVATION_SALT=${OPSCHAIN_KEY_DERIVATION_SALT:-$(openssl rand -hex 32)}
  OPSCHAIN_PRIMARY_KEY=${OPSCHAIN_PRIMARY_KEY:-$(openssl rand -hex 32)}
  OPSCHAIN_DETERMINISTIC_KEY=${OPSCHAIN_DETERMINISTIC_KEY:-$(openssl rand -hex 32)}
  OPSCHAIN_LDAP_PASSWORD=${OPSCHAIN_LDAP_PASSWORD:-$(openssl rand -hex 8)}
  OPSCHAIN_CREATE_LOGS_API_PASSWORD=${OPSCHAIN_CREATE_LOGS_API_PASSWORD:-$(openssl rand -hex 8)}
  OPSCHAIN_IMAGE_REGISTRY_PASSWORD=${OPSCHAIN_IMAGE_REGISTRY_PASSWORD:-$(openssl rand -hex 8)}
}

set_permissions_ids() {
  OPSCHAIN_UID=${OPSCHAIN_UID:-$(id -u)}
  OPSCHAIN_GID=${OPSCHAIN_GID:-$(id -g)}
  echo "OpsChain will run as $OPSCHAIN_UID:$OPSCHAIN_GID (your current user:group)"
}

load_opschain_version() {
  OPSCHAIN_VERSION="$(< RELEASE-VERSION)"
  export OPSCHAIN_VERSION OPSCHAIN_RUNNER_IMAGE=limepoint/opschain-${OPSCHAIN_RUNNER_NAME}:${OPSCHAIN_VERSION}
}

create_values_yaml() {
  if [ -e values.yaml ]; then
    backup=values.yaml.$(date +%Y-%m-%dT%H:%M:%S.%N)
    echo Creating a backup of values.yaml as "${backup}". >&2
    cp values.yaml "${backup}"
  fi
  eval "cat <<EOF
$(<values.template.yaml)
EOF
  " 2>/dev/null > values.yaml
  echo Helm values.yaml created.
}

setup_auth() {
  if ! [[ -e opschain_auth/security_configuration.json ]]; then
    cp -af opschain_auth.tmpl/. opschain_auth
  fi
}

example_env_file=".env.example"

load_saved_settings "${example_env_file}"
load_saved_settings ".env"
load_saved_settings ".env.internal"
check_opschain_licence
generate_secrets
set_permissions_ids

validate_settings
load_opschain_version
save_settings ".env" "${example_env_file}"
create_values_yaml
setup_auth
